"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cpf-cnpj-validator";
exports.ids = ["vendor-chunks/cpf-cnpj-validator"];
exports.modules = {

/***/ "(ssr)/./node_modules/cpf-cnpj-validator/dist/cpf-cnpj-validator.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cpf-cnpj-validator/dist/cpf-cnpj-validator.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cnpj: () => (/* binding */ cnpj),\n/* harmony export */   cpf: () => (/* binding */ cpf),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   validator: () => (/* binding */ validator)\n/* harmony export */ });\n/*!\n * cpf-cnpj-validator v1.0.3\n * (c) 2020-present Carvalho, Vinicius Luiz <carvalho.viniciusluiz@gmail.com>\n * Released under the MIT License.\n */ const BLACKLIST = [\n    \"00000000000\",\n    \"11111111111\",\n    \"22222222222\",\n    \"33333333333\",\n    \"44444444444\",\n    \"55555555555\",\n    \"66666666666\",\n    \"77777777777\",\n    \"88888888888\",\n    \"99999999999\",\n    \"12345678909\"\n];\nconst STRICT_STRIP_REGEX = /[.-]/g;\nconst LOOSE_STRIP_REGEX = /[^\\d]/g;\nconst verifierDigit = (digits)=>{\n    const numbers = digits.split(\"\").map((number)=>{\n        return parseInt(number, 10);\n    });\n    const modulus = numbers.length + 1;\n    const multiplied = numbers.map((number, index)=>number * (modulus - index));\n    const mod = multiplied.reduce((buffer, number)=>buffer + number) % 11;\n    return mod < 2 ? 0 : 11 - mod;\n};\nconst strip = (number, strict)=>{\n    const regex = strict ? STRICT_STRIP_REGEX : LOOSE_STRIP_REGEX;\n    return (number || \"\").replace(regex, \"\");\n};\nconst format = (number)=>{\n    return strip(number).replace(/^(\\d{3})(\\d{3})(\\d{3})(\\d{2})$/, \"$1.$2.$3-$4\");\n};\nconst isValid = (number, strict)=>{\n    const stripped = strip(number, strict);\n    if (!stripped) {\n        return false;\n    }\n    if (stripped.length !== 11) {\n        return false;\n    }\n    if (BLACKLIST.includes(stripped)) {\n        return false;\n    }\n    let numbers = stripped.substr(0, 9);\n    numbers += verifierDigit(numbers);\n    numbers += verifierDigit(numbers);\n    return numbers.substr(-2) === stripped.substr(-2);\n};\nconst generate = (formatted)=>{\n    let numbers = \"\";\n    for(let i = 0; i < 9; i += 1){\n        numbers += Math.floor(Math.random() * 9);\n    }\n    numbers += verifierDigit(numbers);\n    numbers += verifierDigit(numbers);\n    return formatted ? format(numbers) : numbers;\n};\nvar cpf = {\n    verifierDigit,\n    strip,\n    format,\n    isValid,\n    generate\n};\nconst BLACKLIST$1 = [\n    \"00000000000000\",\n    \"11111111111111\",\n    \"22222222222222\",\n    \"33333333333333\",\n    \"44444444444444\",\n    \"55555555555555\",\n    \"66666666666666\",\n    \"77777777777777\",\n    \"88888888888888\",\n    \"99999999999999\"\n];\nconst STRICT_STRIP_REGEX$1 = /[-\\\\/.]/g;\nconst LOOSE_STRIP_REGEX$1 = /[^\\d]/g;\nconst verifierDigit$1 = (digits)=>{\n    let index = 2;\n    const reverse = digits.split(\"\").reduce((buffer, number)=>{\n        return [\n            parseInt(number, 10)\n        ].concat(buffer);\n    }, []);\n    const sum = reverse.reduce((buffer, number)=>{\n        buffer += number * index;\n        index = index === 9 ? 2 : index + 1;\n        return buffer;\n    }, 0);\n    const mod = sum % 11;\n    return mod < 2 ? 0 : 11 - mod;\n};\nconst strip$1 = (number, strict)=>{\n    const regex = strict ? STRICT_STRIP_REGEX$1 : LOOSE_STRIP_REGEX$1;\n    return (number || \"\").replace(regex, \"\");\n};\nconst format$1 = (number)=>{\n    return strip$1(number).replace(/^(\\d{2})(\\d{3})(\\d{3})(\\d{4})(\\d{2})$/, \"$1.$2.$3/$4-$5\");\n};\nconst isValid$1 = (number, strict)=>{\n    const stripped = strip$1(number, strict);\n    if (!stripped) {\n        return false;\n    }\n    if (stripped.length !== 14) {\n        return false;\n    }\n    if (BLACKLIST$1.includes(stripped)) {\n        return false;\n    }\n    let numbers = stripped.substr(0, 12);\n    numbers += verifierDigit$1(numbers);\n    numbers += verifierDigit$1(numbers);\n    return numbers.substr(-2) === stripped.substr(-2);\n};\nconst generate$1 = (formatted)=>{\n    let numbers = \"\";\n    for(let i = 0; i < 12; i += 1){\n        numbers += Math.floor(Math.random() * 9);\n    }\n    numbers += verifierDigit$1(numbers);\n    numbers += verifierDigit$1(numbers);\n    return formatted ? format$1(numbers) : numbers;\n};\nvar cnpj = {\n    verifierDigit: verifierDigit$1,\n    strip: strip$1,\n    format: format$1,\n    isValid: isValid$1,\n    generate: generate$1\n};\nconst validator = (joi)=>({\n        type: \"document\",\n        base: joi.string(),\n        messages: {\n            \"document.cpf\": \"CPF inv\\xe1lido\",\n            \"document.cnpj\": \"CNPJ inv\\xe1lido\"\n        },\n        rules: {\n            cpf: {\n                validate (value, helpers, args, options) {\n                    if (!cpf.isValid(value)) {\n                        return helpers.error(\"document.cpf\");\n                    }\n                    return value;\n                }\n            },\n            cnpj: {\n                validate (value, helpers, args, options) {\n                    if (!cnpj.isValid(value)) {\n                        return helpers.error(\"document.cnpj\");\n                    }\n                    return value;\n                }\n            }\n        }\n    });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validator);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3BmLWNucGotdmFsaWRhdG9yL2Rpc3QvY3BmLWNucGotdmFsaWRhdG9yLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsTUFBTUEsWUFBWTtJQUNkO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxvQkFBb0I7QUFDMUIsTUFBTUMsZ0JBQWdCLENBQUNDO0lBQ25CLE1BQU1DLFVBQVVELE9BQ1hFLEtBQUssQ0FBQyxJQUNOQyxHQUFHLENBQUNDLENBQUFBO1FBQ0wsT0FBT0MsU0FBU0QsUUFBUTtJQUM1QjtJQUNBLE1BQU1FLFVBQVVMLFFBQVFNLE1BQU0sR0FBRztJQUNqQyxNQUFNQyxhQUFhUCxRQUFRRSxHQUFHLENBQUMsQ0FBQ0MsUUFBUUssUUFBVUwsU0FBVUUsQ0FBQUEsVUFBVUcsS0FBSTtJQUMxRSxNQUFNQyxNQUFNRixXQUFXRyxNQUFNLENBQUMsQ0FBQ0MsUUFBUVIsU0FBV1EsU0FBU1IsVUFBVTtJQUNyRSxPQUFRTSxNQUFNLElBQUksSUFBSSxLQUFLQTtBQUMvQjtBQUNBLE1BQU1HLFFBQVEsQ0FBQ1QsUUFBUVU7SUFDbkIsTUFBTUMsUUFBUUQsU0FBU2pCLHFCQUFxQkM7SUFDNUMsT0FBTyxDQUFDTSxVQUFVLEVBQUMsRUFBR1ksT0FBTyxDQUFDRCxPQUFPO0FBQ3pDO0FBQ0EsTUFBTUUsU0FBUyxDQUFDYjtJQUNaLE9BQU9TLE1BQU1ULFFBQVFZLE9BQU8sQ0FBQyxrQ0FBa0M7QUFDbkU7QUFDQSxNQUFNRSxVQUFVLENBQUNkLFFBQVFVO0lBQ3JCLE1BQU1LLFdBQVdOLE1BQU1ULFFBQVFVO0lBQy9CLElBQUksQ0FBQ0ssVUFBVTtRQUNYLE9BQU87SUFDWDtJQUNBLElBQUlBLFNBQVNaLE1BQU0sS0FBSyxJQUFJO1FBQ3hCLE9BQU87SUFDWDtJQUNBLElBQUlYLFVBQVV3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QUFBQSxNQUFRO1FBQ3RCQyxNQUFNO1FBQ05DLE1BQU1GLElBQUlHLE1BQU07UUFDaEJDLFVBQVU7WUFDTixnQkFBZ0I7WUFDaEIsaUJBQWlCO1FBQ3JCO1FBQ0FDLE9BQU87WUFDSG5CLEtBQUs7Z0JBQ0RvQixVQUFTQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxPQUFPO29CQUNsQyxJQUFJLENBQUN4QixJQUFJVixPQUFPLENBQUMrQixRQUFRO3dCQUNyQixPQUFPQyxRQUFRRyxLQUFLLENBQUM7b0JBQ3pCO29CQUNBLE9BQU9KO2dCQUNYO1lBQ0o7WUFDQVQsTUFBTTtnQkFDRlEsVUFBU0MsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsT0FBTztvQkFDbEMsSUFBSSxDQUFDWixLQUFLdEIsT0FBTyxDQUFDK0IsUUFBUTt3QkFDdEIsT0FBT0MsUUFBUUcsS0FBSyxDQUFDO29CQUN6QjtvQkFDQSxPQUFPSjtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtBQUVBLGlFQUFlUixTQUFTQSxFQUFDO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWNoYS1kZS1jYWRhc3Ryby1hc3Jhc3Nlc3NvcmlhLy4vbm9kZV9tb2R1bGVzL2NwZi1jbnBqLXZhbGlkYXRvci9kaXN0L2NwZi1jbnBqLXZhbGlkYXRvci5lcy5qcz8yNWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY3BmLWNucGotdmFsaWRhdG9yIHYxLjAuM1xuICogKGMpIDIwMjAtcHJlc2VudCBDYXJ2YWxobywgVmluaWNpdXMgTHVpeiA8Y2FydmFsaG8udmluaWNpdXNsdWl6QGdtYWlsLmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgQkxBQ0tMSVNUID0gW1xyXG4gICAgJzAwMDAwMDAwMDAwJyxcclxuICAgICcxMTExMTExMTExMScsXHJcbiAgICAnMjIyMjIyMjIyMjInLFxyXG4gICAgJzMzMzMzMzMzMzMzJyxcclxuICAgICc0NDQ0NDQ0NDQ0NCcsXHJcbiAgICAnNTU1NTU1NTU1NTUnLFxyXG4gICAgJzY2NjY2NjY2NjY2JyxcclxuICAgICc3Nzc3Nzc3Nzc3NycsXHJcbiAgICAnODg4ODg4ODg4ODgnLFxyXG4gICAgJzk5OTk5OTk5OTk5JyxcclxuICAgICcxMjM0NTY3ODkwOSdcclxuXTtcclxuY29uc3QgU1RSSUNUX1NUUklQX1JFR0VYID0gL1suLV0vZztcclxuY29uc3QgTE9PU0VfU1RSSVBfUkVHRVggPSAvW15cXGRdL2c7XHJcbmNvbnN0IHZlcmlmaWVyRGlnaXQgPSAoZGlnaXRzKSA9PiB7XHJcbiAgICBjb25zdCBudW1iZXJzID0gZGlnaXRzXHJcbiAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgIC5tYXAobnVtYmVyID0+IHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCAxMCk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG1vZHVsdXMgPSBudW1iZXJzLmxlbmd0aCArIDE7XHJcbiAgICBjb25zdCBtdWx0aXBsaWVkID0gbnVtYmVycy5tYXAoKG51bWJlciwgaW5kZXgpID0+IG51bWJlciAqIChtb2R1bHVzIC0gaW5kZXgpKTtcclxuICAgIGNvbnN0IG1vZCA9IG11bHRpcGxpZWQucmVkdWNlKChidWZmZXIsIG51bWJlcikgPT4gYnVmZmVyICsgbnVtYmVyKSAlIDExO1xyXG4gICAgcmV0dXJuIChtb2QgPCAyID8gMCA6IDExIC0gbW9kKTtcclxufTtcclxuY29uc3Qgc3RyaXAgPSAobnVtYmVyLCBzdHJpY3QpID0+IHtcclxuICAgIGNvbnN0IHJlZ2V4ID0gc3RyaWN0ID8gU1RSSUNUX1NUUklQX1JFR0VYIDogTE9PU0VfU1RSSVBfUkVHRVg7XHJcbiAgICByZXR1cm4gKG51bWJlciB8fCAnJykucmVwbGFjZShyZWdleCwgJycpO1xyXG59O1xyXG5jb25zdCBmb3JtYXQgPSAobnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyaXAobnVtYmVyKS5yZXBsYWNlKC9eKFxcZHszfSkoXFxkezN9KShcXGR7M30pKFxcZHsyfSkkLywgJyQxLiQyLiQzLSQ0Jyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWQgPSAobnVtYmVyLCBzdHJpY3QpID0+IHtcclxuICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXAobnVtYmVyLCBzdHJpY3QpO1xyXG4gICAgaWYgKCFzdHJpcHBlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzdHJpcHBlZC5sZW5ndGggIT09IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKEJMQUNLTElTVC5pbmNsdWRlcyhzdHJpcHBlZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgbnVtYmVycyA9IHN0cmlwcGVkLnN1YnN0cigwLCA5KTtcclxuICAgIG51bWJlcnMgKz0gdmVyaWZpZXJEaWdpdChudW1iZXJzKTtcclxuICAgIG51bWJlcnMgKz0gdmVyaWZpZXJEaWdpdChudW1iZXJzKTtcclxuICAgIHJldHVybiBudW1iZXJzLnN1YnN0cigtMikgPT09IHN0cmlwcGVkLnN1YnN0cigtMik7XHJcbn07XHJcbmNvbnN0IGdlbmVyYXRlID0gKGZvcm1hdHRlZCkgPT4ge1xyXG4gICAgbGV0IG51bWJlcnMgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSArPSAxKSB7XHJcbiAgICAgICAgbnVtYmVycyArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5KTtcclxuICAgIH1cclxuICAgIG51bWJlcnMgKz0gdmVyaWZpZXJEaWdpdChudW1iZXJzKTtcclxuICAgIG51bWJlcnMgKz0gdmVyaWZpZXJEaWdpdChudW1iZXJzKTtcclxuICAgIHJldHVybiAoZm9ybWF0dGVkID8gZm9ybWF0KG51bWJlcnMpIDogbnVtYmVycyk7XHJcbn07XHJcbnZhciBjcGYgPSB7XHJcbiAgICB2ZXJpZmllckRpZ2l0LFxyXG4gICAgc3RyaXAsXHJcbiAgICBmb3JtYXQsXHJcbiAgICBpc1ZhbGlkLFxyXG4gICAgZ2VuZXJhdGUsXHJcbn07XG5cbmNvbnN0IEJMQUNLTElTVCQxID0gW1xyXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcclxuICAgICcxMTExMTExMTExMTExMScsXHJcbiAgICAnMjIyMjIyMjIyMjIyMjInLFxyXG4gICAgJzMzMzMzMzMzMzMzMzMzJyxcclxuICAgICc0NDQ0NDQ0NDQ0NDQ0NCcsXHJcbiAgICAnNTU1NTU1NTU1NTU1NTUnLFxyXG4gICAgJzY2NjY2NjY2NjY2NjY2JyxcclxuICAgICc3Nzc3Nzc3Nzc3Nzc3NycsXHJcbiAgICAnODg4ODg4ODg4ODg4ODgnLFxyXG4gICAgJzk5OTk5OTk5OTk5OTk5J1xyXG5dO1xyXG5jb25zdCBTVFJJQ1RfU1RSSVBfUkVHRVgkMSA9IC9bLVxcXFwvLl0vZztcclxuY29uc3QgTE9PU0VfU1RSSVBfUkVHRVgkMSA9IC9bXlxcZF0vZztcclxuY29uc3QgdmVyaWZpZXJEaWdpdCQxID0gKGRpZ2l0cykgPT4ge1xyXG4gICAgbGV0IGluZGV4ID0gMjtcclxuICAgIGNvbnN0IHJldmVyc2UgPSBkaWdpdHMuc3BsaXQoJycpLnJlZHVjZSgoYnVmZmVyLCBudW1iZXIpID0+IHtcclxuICAgICAgICByZXR1cm4gW3BhcnNlSW50KG51bWJlciwgMTApXS5jb25jYXQoYnVmZmVyKTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHN1bSA9IHJldmVyc2UucmVkdWNlKChidWZmZXIsIG51bWJlcikgPT4ge1xyXG4gICAgICAgIGJ1ZmZlciArPSBudW1iZXIgKiBpbmRleDtcclxuICAgICAgICBpbmRleCA9IChpbmRleCA9PT0gOSA/IDIgOiBpbmRleCArIDEpO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9LCAwKTtcclxuICAgIGNvbnN0IG1vZCA9IHN1bSAlIDExO1xyXG4gICAgcmV0dXJuIChtb2QgPCAyID8gMCA6IDExIC0gbW9kKTtcclxufTtcclxuY29uc3Qgc3RyaXAkMSA9IChudW1iZXIsIHN0cmljdCkgPT4ge1xyXG4gICAgY29uc3QgcmVnZXggPSBzdHJpY3QgPyBTVFJJQ1RfU1RSSVBfUkVHRVgkMSA6IExPT1NFX1NUUklQX1JFR0VYJDE7XHJcbiAgICByZXR1cm4gKG51bWJlciB8fCAnJykucmVwbGFjZShyZWdleCwgJycpO1xyXG59O1xyXG5jb25zdCBmb3JtYXQkMSA9IChudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBzdHJpcCQxKG51bWJlcikucmVwbGFjZSgvXihcXGR7Mn0pKFxcZHszfSkoXFxkezN9KShcXGR7NH0pKFxcZHsyfSkkLywgJyQxLiQyLiQzLyQ0LSQ1Jyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWQkMSA9IChudW1iZXIsIHN0cmljdCkgPT4ge1xyXG4gICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcCQxKG51bWJlciwgc3RyaWN0KTtcclxuICAgIGlmICghc3RyaXBwZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RyaXBwZWQubGVuZ3RoICE9PSAxNCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChCTEFDS0xJU1QkMS5pbmNsdWRlcyhzdHJpcHBlZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgbnVtYmVycyA9IHN0cmlwcGVkLnN1YnN0cigwLCAxMik7XHJcbiAgICBudW1iZXJzICs9IHZlcmlmaWVyRGlnaXQkMShudW1iZXJzKTtcclxuICAgIG51bWJlcnMgKz0gdmVyaWZpZXJEaWdpdCQxKG51bWJlcnMpO1xyXG4gICAgcmV0dXJuIG51bWJlcnMuc3Vic3RyKC0yKSA9PT0gc3RyaXBwZWQuc3Vic3RyKC0yKTtcclxufTtcclxuY29uc3QgZ2VuZXJhdGUkMSA9IChmb3JtYXR0ZWQpID0+IHtcclxuICAgIGxldCBudW1iZXJzID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpICs9IDEpIHtcclxuICAgICAgICBudW1iZXJzICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkpO1xyXG4gICAgfVxyXG4gICAgbnVtYmVycyArPSB2ZXJpZmllckRpZ2l0JDEobnVtYmVycyk7XHJcbiAgICBudW1iZXJzICs9IHZlcmlmaWVyRGlnaXQkMShudW1iZXJzKTtcclxuICAgIHJldHVybiAoZm9ybWF0dGVkID8gZm9ybWF0JDEobnVtYmVycykgOiBudW1iZXJzKTtcclxufTtcclxudmFyIGNucGogPSB7XHJcbiAgICB2ZXJpZmllckRpZ2l0OiB2ZXJpZmllckRpZ2l0JDEsXHJcbiAgICBzdHJpcDogc3RyaXAkMSxcclxuICAgIGZvcm1hdDogZm9ybWF0JDEsXHJcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkJDEsXHJcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMVxyXG59O1xuXG5jb25zdCB2YWxpZGF0b3IgPSBqb2kgPT4gKHtcclxuICAgIHR5cGU6ICdkb2N1bWVudCcsXHJcbiAgICBiYXNlOiBqb2kuc3RyaW5nKCksXHJcbiAgICBtZXNzYWdlczoge1xyXG4gICAgICAgICdkb2N1bWVudC5jcGYnOiAnQ1BGIGludsOhbGlkbycsXHJcbiAgICAgICAgJ2RvY3VtZW50LmNucGonOiAnQ05QSiBpbnbDoWxpZG8nXHJcbiAgICB9LFxyXG4gICAgcnVsZXM6IHtcclxuICAgICAgICBjcGY6IHtcclxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3BmLmlzVmFsaWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2RvY3VtZW50LmNwZicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbnBqOiB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCBhcmdzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNucGouaXNWYWxpZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZG9jdW1lbnQuY25waicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdG9yO1xuZXhwb3J0IHsgY3BmLCBjbnBqLCB2YWxpZGF0b3IgfTtcbiJdLCJuYW1lcyI6WyJCTEFDS0xJU1QiLCJTVFJJQ1RfU1RSSVBfUkVHRVgiLCJMT09TRV9TVFJJUF9SRUdFWCIsInZlcmlmaWVyRGlnaXQiLCJkaWdpdHMiLCJudW1iZXJzIiwic3BsaXQiLCJtYXAiLCJudW1iZXIiLCJwYXJzZUludCIsIm1vZHVsdXMiLCJsZW5ndGgiLCJtdWx0aXBsaWVkIiwiaW5kZXgiLCJtb2QiLCJyZWR1Y2UiLCJidWZmZXIiLCJzdHJpcCIsInN0cmljdCIsInJlZ2V4IiwicmVwbGFjZSIsImZvcm1hdCIsImlzVmFsaWQiLCJzdHJpcHBlZCIsImluY2x1ZGVzIiwic3Vic3RyIiwiZ2VuZXJhdGUiLCJmb3JtYXR0ZWQiLCJpIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiY3BmIiwiQkxBQ0tMSVNUJDEiLCJTVFJJQ1RfU1RSSVBfUkVHRVgkMSIsIkxPT1NFX1NUUklQX1JFR0VYJDEiLCJ2ZXJpZmllckRpZ2l0JDEiLCJyZXZlcnNlIiwiY29uY2F0Iiwic3VtIiwic3RyaXAkMSIsImZvcm1hdCQxIiwiaXNWYWxpZCQxIiwiZ2VuZXJhdGUkMSIsImNucGoiLCJ2YWxpZGF0b3IiLCJqb2kiLCJ0eXBlIiwiYmFzZSIsInN0cmluZyIsIm1lc3NhZ2VzIiwicnVsZXMiLCJ2YWxpZGF0ZSIsInZhbHVlIiwiaGVscGVycyIsImFyZ3MiLCJvcHRpb25zIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cpf-cnpj-validator/dist/cpf-cnpj-validator.es.js\n");

/***/ })

};
;